## 数据结构中的经典排序算法Java实现

### - 快速排序算法

```
public class QuickSortCcc {

/**
 * @Description: zfc
 * Created by shanzhihong on 2019/06/27-21:38.
 * @version 1.0
 */
    /**
     * int数组 快速排序函数
     * @param arr
     */
    public void QuickSort(int[] arr){
        if (arr.length > 1){
            sort(arr,0,arr.length-1);
        }else {
            return;
        }
    }
    /**
     * 分治法，递归排序，递归的出口是low = high
     * @param arr
     * @param low
     * @param high
     */
    public void sort(int[] arr, int low, int high){
        if (low < high){
            int point = partition(arr, low, high);
            sort(arr,low,point-1);
            sort(arr,point+1, high);
        }else {
            return;
        }
    }
    /**
     * 返回快排的基准位置，并对基准左右进行调整
     * @param arr
     * @param low
     * @param high
     * @return 基准位置
     */
    public int partition(int[] arr, int low, int high){
        int pivot = arr[low];
        while (low < high){
            while (low < high){
                if (arr[high] < pivot){
                    //交换
                    swap(arr, low, high);
                    break;//调整左边
                }else {
                    high--;
                }
            }
            while (low <  high){
                if (arr[low] > pivot){
                    //交换
                    swap(arr, low, high);
                    break;
                }else {
                    low++;
                }
            }
        }
        //跳出循环，则low = high, low的位置就是基准的位置
        return low;
    }
    /**
     * 交换数组中a,b位置的值
     * @param arr
     * @param a
     * @param b
     */
    public void swap(int[] arr,int a, int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    /**
     * main()
     * @param args
     */
    public static void main(String[] args){
        QuickSortCcc quickSortCcc = new QuickSortCcc();
        int[] arr = new int[]{5,6,3,2,2,7,8,4,1111,10,10,100};
        quickSortCcc.QuickSort(arr);
        for (int i:arr){
            System.out.print(" "+i+" ");
        }
    }
}
```

----

优化思想：

- **随机选取法**
  
  引入原因：**在待排序列是部分有序时，固定选取基准使快排效率底下，要缓解这种情况，就引入了随机选取基准**
  
  　　思路：使用随机数生成函数生成一个随机数rand，随机数的范围为[left, right]，并用此随机数为下标对应的元素a[rand]作为中轴，并与最后一个元素a[right]交换，然后进行快排即可。
  
  　　优点：这是一种相对安全的策略。由于基准的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。

- **三数取中**
  
  **引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了**三数取中**选取枢轴**
  
  思路：假设数组被排序的范围为left和right，center=()left+right)/2，对a[left]、a[right]和a[center]进行适当排序，取中值为中轴，将最小者放a[left]，最大者放在a[right]，把中轴元与a[right-1]交换，并在分割阶段将i和j初始化为left+1和right-2。然后使用双向描述法，进行快排。
  
  　　分割好处：　　　　　　
  
  　　　　1.将三元素中最小者被分到a[left]、最大者分到a[right]是正确的，因为当快排一趟后，比中轴小的放到左边，而比中轴大的放到右边，这样就在分割的时候把它们分到了正确的位置，减少了一次比较和交换。
  
  　　　　2.在前面所说的所有算法中，都有双向扫描时的越界问题，而使用这个分割策略则可以解决这个问题。因为i向右扫描时，必然会遇到不小于中轴的数a[right-1]，而j在向左扫描时，必然会遇到不大于中轴的数a[left]，这样，a[right-1]和a[left]提供了一个警戒标记，所以不需要检查下标越界的问题。
  
  　　分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数。

- **进一步优化**
  
  上述三种优化快排方法，在处理重复数的时候，效率并没有很大提高，因此，我们可以想办法优化。
  
  - **当待排序序列长度分割到一定大小后，使用插入排序。**
  
  　　原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。
  
  ```
  if (high - low + 1 < 10)
   {
   InsertSort(arr,low,high); return;
   }//else时，正常执行快排
  ```
  
  - **在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割（处理重复效率极高）**
    
    ```
    举例：

    　　　　待排序序列 1 4 6 7 6 6 7 6 8 6

    　　　　三数取中选取枢轴：下标为4的数6

    　　　　转换后，待分割序列：6 4 6 7 1 6 7 6 8 6  枢轴key：6

    　　　　本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6

    　　　　下次的两个子序列为：1 4 6 和 7 6 7 6 8 6

    　　　　本次划分后，对与key元素相等处理的结果：1 4 6 6 6 6 6 7 8 7

    　　　　下次的两个子序列为：1 4 和 7 8 7

    　　　　经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少。
    　　　　

    　　具体过程：在处理过程中，会有两个步骤

    　　　　第一步，在划分过程中，把与key相等元素放入数组的两端

    　　　　第二步，划分结束后，把与key相等的元素移到枢轴周围
    　　　　

    　　举例：

    　　　　待排序序列 1 4 6 7 6 6 7 6 8 6

    　　　　三数取中选取枢轴：下标为4的数6

    　　　　转换后，待分割序列：6 4 6 7 1 6 7 6 8 6  枢轴key：6

    　　　　第一步，在划分过程中，把与key相等元素放入数组的两端

    　　　　结果为：6 4 1 6(枢轴) 7 8 7 6 6 6

    　　　　此时，与6相等的元素全放入在两端了

    　　　　第二步，划分结束后，把与key相等的元素移到枢轴周围

    　　　　结果为：1 4 66(枢轴)  6 6 6 7 8 7

    　　　　此时，与6相等的元素全移到枢轴周围了

    　　　　之后，在1 4 和 7 8 7两个子序列进行快排
    ```
  
  - **优化递归操作**
    
            快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。
    
    　　优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。
    
    ```
    //综合使用插入排序和快速排序
    void QSort(int arr[],int low,int high)  
    {   
        int pivotPos = -1;  
        if (high - low + 1 < 10)  
        {  
            InsertSort(arr,low,high);  
            return;  
        }  
        while(low < high)  
        {  
            pivotPos = Partition(arr,low,high);  
            QSort(arr,low,pivot-1);  
            low = pivot + 1;  
        }  
    }
    ```
    
    
